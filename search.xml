<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Pattern和Matcher的使用]]></title>
    <url>%2F2018%2F12%2F25%2FPattern%E5%92%8CMatcher%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Pattern的使用Pattern类用于创建一个正则表达式,也可以说创建一个匹配模式,它的构造方法是私有的,不可以直接创建,但可以通过Pattern.complie(String regex)简单工厂方法创建一个正则表达式。 123Pattern p = Pattern.compile("\\w+"); p.pattern();//返回 \w+//pattern() 返回正则表达式的字符串形式,其实就是返回Pattern.complile(String regex)的regex参数. split(CharSequence input)方法Pattern有一个split(CharSequence input)方法,用于分隔字符串,并返回一个String[],我猜String.split(String regex)就是通过Pattern.split(CharSequence input)来实现的。 123Pattern p = Pattern.compile("\\d+"); String[] str = p.split("我的QQ是:456456我的电话是:0532214我的邮箱是:aaa@aaa.com"); //结果:str[0]="我的QQ是:" str[1]="我的电话是:" str[2]="我的邮箱是:aaa@aaa.com" matches(String regex,CharSequence input)方法Pattern.matches(String regex,CharSequence input)是一个静态方法,用于快速匹配字符串,该方法适合用于只匹配一次,且匹配全部字符串.。 123Pattern.matches("\\d+","2223");//返回true Pattern.matches("\\d+","2223aa");//返回false,需要匹配到所有字符串才能返回true,这里aa不能匹配到 Pattern.matches("\\d+","22bb23");//返回false,需要匹配到所有字符串才能返回true,这里bb不能匹配到 matcher(CharSequence input) 方法Pattern.matcher(CharSequence input)返回一个Matcher对象. Matcher类的构造方法也是私有的,不能随意创建,只能通过Pattern.matcher(CharSequence input)方法得到该类的实例. Pattern类只能做一些简单的匹配操作,要想得到更强更便捷的正则匹配操作,那就需要将Pattern与Matcher一起合作.Matcher类提供了对正则表达式的分组支持,以及对正则表达式的多次匹配支持。 123Pattern p = Pattern.compile("\\d+"); Matcher m = p.matcher("22bb23"); m.pattern();//返回p 也就是返回该Matcher对象是由哪个Pattern对象的创建的 Matcher的使用Matcher.matches()matches()对整个字符串进行匹配,只有整个字符串都匹配了才返回true。 12345Pattern p=Pattern.compile("\\d+"); Matcher m=p.matcher("22bb23"); m.matches();//返回false,因为bb不能被\d+匹配,导致整个字符串匹配未成功. Matcher m2=p.matcher("2223"); m2.matches();//返回true,因为\d+匹配到了整个字符串 我们现在回头看一下Pattern.matches(String regex,CharSequence input),它与下面这段代码等价 Pattern.compile(regex).matcher(input).matches()。 Matcher.lookingAt()lookingAt()对前面的字符串进行匹配,只有匹配到的字符串在最前面才返回true。 12345Pattern p=Pattern.compile("\\d+"); Matcher m=p.matcher("22bb23"); m.lookingAt();//返回true,因为\d+匹配到了前面的22 Matcher m2=p.matcher("aa2223"); m2.lookingAt();//返回false,因为\d+不能匹配前面的aa Matcher.find()find()对字符串进行匹配,匹配到的字符串可以在任何位置。 123456789Pattern p=Pattern.compile("\\d+"); Matcher m=p.matcher("22bb23"); m.find();//返回true Matcher m2=p.matcher("aa2223"); m2.find();//返回true Matcher m3=p.matcher("aa2223bb"); m3.find();//返回true Matcher m4=p.matcher("aabb"); m4.find();//返回false Mathcer.start()/ Matcher.end()/ Matcher.group()当使用matches(),lookingAt(),find()执行匹配操作后,就可以利用以上三个方法得到更详细的信息. start()返回匹配到的子字符串在字符串中的索引位置. end()返回匹配到的子字符串的最后一个字符在字符串中的索引位置. group()返回匹配到的子字符串 . 123456789101112131415161718Pattern p=Pattern.compile("\\d+"); Matcher m=p.matcher("aaa2223bb"); m.find();//匹配2223 m.start();//返回3 m.end();//返回7,返回的是2223后的索引号 m.group();//返回2223 Mathcer m2=p.matcher("2223bb"); m2.lookingAt(); //匹配2223 m2.start(); //返回0,由于lookingAt()只能匹配前面的字符串,所以当使用lookingAt()匹配时,start()方法总是返回0 m2.end(); //返回4 m2.group(); //返回2223 Matcher m3=p.matcher("2223"); //如果Matcher m3=p.matcher("2223bb"); 那么下面的方法出错，因为不匹配返回falsem3.matches(); //匹配整个字符串 m3.start(); //返回0m3.end(); //返回3,原因相信大家也清楚了,因为matches()需要匹配所有字符串 m3.group(); //返回2223 说了这么多,相信大家都明白了以上几个方法的使用,该说说正则表达式的分组在java中是怎么使用的. start(),end(),group()均有一个重载方法它们是start(int i),end(int i),group(int i)专用于分组操作,Mathcer类还有一个groupCount()用于返回有多少组. 12345678910Pattern p=Pattern.compile("([a-z]+)(\\d+)"); Matcher m=p.matcher("aaa2223bb"); m.find(); //匹配aaa2223 m.groupCount(); //返回2,因为有2组 m.start(1); //返回0 返回第一组匹配到的子字符串在字符串中的索引号 m.start(2); //返回3 m.end(1); //返回3 返回第一组匹配到的子字符串的最后一个字符在字符串中的索引位置. m.end(2); //返回7 m.group(1); //返回aaa,返回第一组匹配到的子字符串 m.group(2); //返回2223,返回第二组匹配到的子字符串 现在我们使用一下稍微高级点的正则匹配操作,例如有一段文本,里面有很多数字,而且这些数字是分开的,我们现在要将文本中所有数字都取出来,利用java的正则操作是那么的简单. 1234567891011121314151617181920212223Pattern p=Pattern.compile("\\d+"); Matcher m=p.matcher("我的QQ是:456456 我的电话是:0532214 我的邮箱是:aaa123@aaa.com"); while(m.find()) &#123; System.out.println(m.group()); &#125; //输出: //456456 //0532214 //123//如将以上while()循环替换成 while(m.find()) &#123; System.out.println(m.group()); System.out.print("start:"+m.start()); System.out.println(" end:"+m.end()); &#125; //则输出: //456456 //start:6 end:12 //0532214 //start:19 end:26 //123 //start:36 end:39 注意:只有当匹配操作成功,才可以使用start(),end(),group()三个方法,否则会抛出java.lang.IllegalStateException,也就是当matches(),lookingAt(),find()其中任意一个方法返回true时,才可以使用. 注：本文参考gdwkong]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F12%2F25%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则基础知识点元字符万物皆有缘，正则也是如此，元字符是构造正则表达式的一种基本元素。 我们先来记几个常用的元字符： 元字符 说明 . 匹配除换行符以外的任意字符 \w 匹配字母或数字或下划线或汉字 \s 匹配任意的空白符 \d 匹配数字 \b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 有了元字符之后，我们就可以利用这些元字符来写一些简单的正则表达式了， 比如： 匹配有abc开头的字符串： 1\babc或者^abc 匹配8位数字的QQ号码： 1^\d\d\d\d\d\d\d\d$ 匹配1开头11位数字的手机号码： 1^1\d\d\d\d\d\d\d\d\d\d$ 重复限定符有了元字符就可以写不少的正则表达式了，但细心的你们可能会发现：别人写的正则简洁明了，而不理君写的正则一堆乱七八糟而且重复的元字符组成的。正则没提供办法处理这些重复的元字符吗？ 答案是有的！ 为了处理这些重复问题，正则表达式中一些重复限定符，把重复部分用合适的限定符替代，下面我们来看一些限定符： 语法 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 有了这些限定符之后，我们就可以对之前的正则表达式进行改造了，比如： 匹配8位数字的QQ号码： 1^\d&#123;8&#125;$ 匹配1开头11位数字的手机号码： 1^1\d&#123;10&#125;$ 匹配银行卡号是14~18位的数字： 1^\d&#123;14,18&#125;$ 匹配以a开头的，0个或多个b结尾的字符串 1^ab*$ 分组从上面的例子（4）中看到，限定符是作用在与他左边最近的一个字符，那么问题来了，如果我想要ab同时被限定那怎么办呢？ 1正则表达式中用小括号()来做分组，也就是括号中的内容作为一个整体。 因此当我们要匹配多个ab时，我们可以这样。 如：匹配字符串中包含0到多个ab开头： 1^(ab)* 转义我们看到正则表达式用小括号来做分组，那么问题来了： 1如果要匹配的字符串中本身就包含小括号，那是不是冲突？应该怎么办？ 针对这种情况，正则提供了转义的方式，也就是要把这些元字符、限定符或者关键字转义成普通的字符，做法很简答，就是在要转义的字符前面加个斜杠，也就是\即可。 如：要匹配以(ab)开头 1^(\(ab\))* 条件或回到我们刚才的手机号匹配，我们都知道：国内号码都来自三大网，它们都有属于自己的号段，比如联通有130/131/132/155/156/185/186/145/176等号段，假如让我们匹配一个联通的号码，那按照我们目前所学到的正则，应该无从下手的，因为这里包含了一些并列的条件，也就是“或”，那么在正则中是如何表示“或”的呢? 1正则用符号 | 来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。 那么我们就可以用或条件来处理这个问题 1^(130|131|132|155|156|185|186|145|176)\d&#123;8&#125;$ 区间看到上面的例子，是不是看到有什么规律？是不是还有一种想要简化的冲动？ 实际是有的 1234正则提供一个元字符中括号 [] 来表示区间条件。限定0到9 可以写成[0-9]限定A-Z 写成[A-Z]限定某些数字 [165] 那上面的正则我们还改成这样： 1^((13[0-2])|(15[56])|(18[5-6])|145|176)\d&#123;8&#125;$ 好了，正则表达式的基本用法就讲到这里了，其实它还有非常多的知识点以及元字符，我们在此只列举了部分元字符和语法来讲，旨在给那些不懂正则或者想学正则但有看不下去文档的人做一个快速入门级的教程，看完本教程，即使你不能写出高大上的正则，至少也能写一些简单的正则或者看得懂别人写的正则了。 正则进阶知识点零宽断言无论是零宽还是断言，听起来都古古怪怪的， 那先解释一下这两个词。 12断言：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面或后面会出现满足指定规则的内容，意思正则也可以像人类那样断定什么什么，比如"ss1aa2bb3",正则可以用断言找出aa2后面有bb3，也可以找出aa2前面有ss1.零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。 意思是讲明白了，那他有什么用呢？ 我们来举个栗子： 假设我们要用爬虫抓取csdn里的文章阅读量。通过查看源代码可以看到文章阅读量这个内容是这样的结构： 1"&lt;span class="read-count"&gt;阅读数：641&lt;/span&gt;" 其中也就‘641’这个是变量，也就是说不同文章不同的值，当我们拿到这个字符串时，需要获得这里边的‘641’有很多种办法，但如果正则应该怎么匹配呢？ 下面先来讲几种类型的断言： 正向先行断言123正向先行断言（正前瞻）：语法：（?=pattern）作用：匹配pattern表达式的前面内容，不返回本身 这样子说，还是一脸懵逼，好吧，回归刚才那个栗子，要取到阅读量，在正则表达式中就意味着要能匹配到‘’前面的数字内容 按照上所说的正向先行断言可以匹配表达式前面的内容，那意思就是:(?=) 就可以匹配到前面的内容了。 匹配什么内容呢？如果要所有内容那就是： 12345678910String reg = ".+(?=&lt;/span&gt;)";String test = "&lt;span class=\"read-count\"&gt;阅读数：641&lt;/span&gt;";Pattern pattern = Pattern.compile(reg);Matcher mc = pattern.matcher(test);while(mc.find())&#123; System.out.println("匹配结果：") System.out.println(mc.group());&#125;//匹配结果：//&lt;span class="read-count"&gt;阅读数：641 可是老哥我们要的只是前面的数字呀，那也简单咯，匹配数字 \d,那可以改成： 123456789String reg = "\\d+(?=&lt;/span&gt;)";String test = "&lt;span class=\"read-count\"&gt;阅读数：641&lt;/span&gt;";Pattern pattern = Pattern.compile(reg);Matcher mc = pattern.matcher(test);while(mc.find())&#123; System.out.println(mc.group());&#125;//匹配结果：//641 正向后行断言123正向后行断言（正后顾）:语法：（?&lt;=pattern）作用：匹配pattern表达式的后面的内容，不返回本身。 有先行就有后行，先行是匹配前面的内容，那后行就是匹配后面的内容啦。 上面的栗子，我们也可以用后行断言来处理. 12345678910 //(?&lt;=&lt;span class="read-count"&gt;阅读数：)\d+ String reg="(?&lt;=&lt;span class=\"read-count\"&gt;阅读数：)\\d+"; String test = "&lt;span class=\"read-count\"&gt;阅读数：641&lt;/span&gt;"; Pattern pattern = Pattern.compile(reg); Matcher mc= pattern.matcher(test); while(mc.find())&#123; System.out.println(mc.group()); &#125;//匹配结果：//641 负向先行断言123负向先行断言（负前瞻）语法：(?!pattern)作用：匹配非pattern表达式的前面内容，不返回本身 有正向也有负向，负向在这里其实就是非的意思。 举个栗子：比如有一句 “我爱祖国，我是祖国的花朵” 现在要找到不是’的花朵’前面的祖国 用正则就可以这样写： 1祖国(?!的花朵) 负向后行断言123负向后行断言（负后顾）语法：(?&lt;!pattern)作用：匹配非pattern表达式的后面内容，不返回本身。 捕获和非捕获单纯说到捕获，他的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组” 1捕获组：匹配子表达式的内容，把匹配结果保存到内存中中数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果 而根据命名方式的不同，又可以分为两种组： 数字编号捕获组123456数字编号捕获组：语法：(exp)解释：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第0组为整个表达式，第一组开始为分组。比如固定电话的：020-85653333他的正则表达式为：(0\d&#123;2&#125;)-(\d&#123;8&#125;)按照左括号的顺序，这个表达式有如下分组： 序号 编号 分组 内容 0 0 (0\d{2})-(\d{8}) 020-85653333 1 1 (0\d{2}) 020 2 2 (\d{8}) 85653333 我们用Java来验证一下： 1234567891011121314String test = "020-85653333";String reg = "(0\\d&#123;2&#125;)-(\\d&#123;8&#125;)";Pattern pattern = Pattern.compile(reg);Matcher mc = pattern.matcher(test);if(mc.find())&#123; System.out.println("分组的个数有：" + mc.groupCount()); for(int i=0;i&lt;=mc.groupCount();i++)&#123; System.out.println("第" + i + "个分组为：" + mc.group(i)); &#125;&#125;//分组的个数有：2//第0个分组为：020-85653333//第1个分组为：020//第2个分组为：85653333 可见，分组个数是2，但是因为第0个为整个表达式本身，因此也一起输出了。 命名编号捕获组12345命名编号捕获组：语法：(?&lt;name&gt;exp)解释：分组的命名由表达式中的name指定比如区号也可以这样写:(?&lt;quhao&gt;\0\d&#123;2&#125;)-(?&lt;haoma&gt;\d&#123;8&#125;)按照左括号的顺序，这个表达式有如下分组： 序号 名称 分组 内容 0 0 (0\d{2})-(\d{8}) 020-85653333 1 quhao (0\d{2}) 020 2 haoma (\d{8}) 85653333 用代码来验证一下： 123456789101112String test = "020-85653333";String reg = "(?&lt;quhao&gt;0\\d&#123;2&#125;)-(?&lt;haoma&gt;\\d&#123;8&#125;)";Pattern pattern = Pattern.compile(reg);Matcher mc = pattern.matcher(test);if(mc.find())&#123; System.out.println("分组的个数有：" + mc.groupCount()); System.out.println(mc.group("quhao")); System.out.println(mc.group("haoma"));&#125;//分组的个数有：2//分组名称为:quhao,匹配内容为：020//分组名称为:haoma,匹配内容为：85653333 非捕获组123非捕获组：语法：(?:exp)解释：和捕获组刚好相反，它用来标识那些不需要捕获的分组，说的通俗一点，就是你可以根据需要去保存你的分组。 比如上面的正则表达式，程序不需要用到第一个分组，那就可以这样写： 序号 编号 分组 内容 0 0 (0\d{2})-(\d{8}) 020-85653333 1 1 (\d{8}) 85653333 验证一下： 12345678910111213String test = "020-85653333";String reg = "(?:0\\d&#123;2&#125;)-(\\d&#123;8&#125;)";Pattern pattern = Pattern.compile(reg);Matcher mc = pattern.matcher(test);if(mc.find())&#123; System.out.println("分组的个数有："+mc.groupCount()); for(int i=0;i&lt;=mc.groupCount();i++)&#123; System.out.println("第"+i+"个分组为："+mc.group(i)); &#125;&#125;//分组的个数有：1//第0个分组为：020-85653333//第1个分组为：85653333 反向引用上面讲到捕获，我们知道：捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用。 举栗子吧： 比如要查找一串字母”aabbbbgbddesddfiid”里成对的字母 如果按照我们之前学到的正则，什么区间啊限定啊断言啊可能是办不到的， 现在我们先用程序思维理一下思路： 123匹配到一个字母匹配第下一个字母，检查是否和上一个字母是否一样如果一样，则匹配成功，否则失败 这里的思路2中匹配下一个字母时，需要用到上一个字母，那怎么记住上一个字母呢？？？这下子捕获就有用处啦，我们可以利用捕获把上一个匹配成功的内容用来作为本次匹配的条件好了，有思路就要实践首先匹配一个字母：\w我们需要做成分组才能捕获，因此写成这样：(\w) 那这个表达式就有一个捕获组：（\w）然后我们要用这个捕获组作为条件，那就可以：(\w)\1这样就大功告成了可能有人不明白了，\1是什么意思呢？还记得捕获组有两种命名方式吗，一种是是根据捕获分组顺序命名，一种是自定义命名来作为捕获组的命名在默认情况下都是以数字来命名，而且数字命名的顺序是从1开始的因此要引用第一个捕获组，根据反向引用的数字命名规则 就需要 \k或者\1当然，通常都是是后者。我们来测试一下： 123456789101112String test = "aabbbbgbddesddfiid";Pattern pattern = Pattern.compile("(\\w)\\1");Matcher mc= pattern.matcher(test);while(mc.find())&#123; System.out.println(mc.group());&#125;//aa//bb//bb//dd//dd//ii 贪婪和非贪婪贪婪我们都知道，贪婪就是不满足，尽可能多的要。 在正则中，贪婪也是差不多的意思: 12贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。特性：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配-舍弃的方式也叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。 前面我们讲过重复限定符，其实这些限定符就是贪婪量词，比如表达式 1\d&#123;3,6&#125; 用来匹配3到6位数字，在这种情况下，它是一种贪婪模式的匹配，也就是假如字符串里有6个个数字可以匹配，那它就是全部匹配到。 如 123456789101112131415String reg = "\\d&#123;3,6&#125;"; String test = "61762828 176 2991 871";System.out.println("文本："+test);System.out.println("贪婪模式："+reg);Pattern p1 = Pattern.compile(reg);Matcher m1 = p1.matcher(test);while(m1.find())&#123; System.out.println("匹配结果：" + m1.group(0));&#125;//文本：61762828 176 2991 44 871//贪婪模式：\d&#123;3,6&#125;//匹配结果：617628//匹配结果：176//匹配结果：2991//匹配结果：871 那有人会问，如果多个贪婪量词凑在一起，那他们是如何支配自己的匹配权的呢？ 1是这样的，多个贪婪在一起时，如果字符串能满足他们各自最大程度的匹配时，就互不干扰，但如果不能满足时，会根据深度优先原则，也就是从左到右的每一个贪婪量词，优先最大数量的满足，剩余再分配下一个量词匹配。 1234567891011121314String reg="(\\d&#123;1,2&#125;)(\\d&#123;3,4&#125;)"; String test="61762828 176 2991 87321";System.out.println("文本："+test);System.out.println("贪婪模式："+reg);Pattern p1 =Pattern.compile(reg);Matcher m1 = p1.matcher(test);while(m1.find())&#123; System.out.println("匹配结果："+m1.group(0));&#125;//文本：61762828 176 2991 87321//贪婪模式：(\d&#123;1,2&#125;)(\d&#123;3,4&#125;)//匹配结果：617628//匹配结果：2991//匹配结果：87321 123"617628" 是前面的\d&#123;1,2&#125;匹配出了61，后面的匹配出了7628"2991" 是前面的\d&#123;1,2&#125;匹配出了29 ，后面的匹配出了91"87321"是前面的\d&#123;1,2&#125;匹配出了87，后面的匹配出了321 懒惰12懒惰匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，这匹配方式叫做懒惰匹配。特性：从左到右，从字符串的最左边开始匹配，每次试图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，依此循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。 懒惰量词是在贪婪量词后面加个“？” 代码 说明 *? 重复任意次，但尽可能少重复 +? 重复1次或更多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {n,m}? 重复n到m次，但尽可能少重复 {n,}? 重复n次以上，但尽可能少重复 1234567891011121314String reg = "(\\d&#123;1,2&#125;?)(\\d&#123;3,4&#125;)"; String test = "61762828 176 2991 87321";System.out.println("文本：" + test);System.out.println("贪婪模式：" + reg);Pattern p1 = Pattern.compile(reg);Matcher m1 = p1.matcher(test);while(m1.find())&#123; System.out.println("匹配结果：" + m1.group(0));&#125;//文本：61762828 176 2991 87321//贪婪模式：(\d&#123;1,2&#125;?)(\d&#123;3,4&#125;)//匹配结果：61762//匹配结果：2991//匹配结果：87321 123"61762" 是左边的懒惰匹配出6，右边的贪婪匹配出1762"2991" 是左边的懒惰匹配出2，右边的贪婪匹配出991"87321" 左边的懒惰匹配出8，右边的贪婪匹配出7321 反义前面说到元字符的都是要匹配什么什么，当然如果你想反着来，不想匹配某些字符，正则也提供了一些常用的反义元字符： 元字符 解释 \W 匹配任意不是字母，数字，下划线，汉字的字符 \S 匹配任意不是空白符的字符 \D 匹配任意非数字的字符 \B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 正则进阶知识就讲到这里，正则是一门博大精深的语言，其实学会它的一些语法和知识点还算不太难，但想要做到真正学以致用能写出非常6的正则，还有很远的距离，只有真正对它感兴趣的，并且经常研究和使用它，才会渐渐的理解它的博大精深之处，我就带你们走到这，剩下的，靠自己啦。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调试jdk源码无法显示变量值]]></title>
    <url>%2F2018%2F11%2F23%2F%E8%B0%83%E8%AF%95jdk%E6%BA%90%E7%A0%81%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%8F%98%E9%87%8F%E5%80%BC%2F</url>
    <content type="text"><![CDATA[在调试代码时，有时需要看下jdk源码的逻辑，但是F5进入方法之后，发现没法看变量的值，给调试带来很大的麻烦，这是因为在jdk中，sun公司对rt.jar中的类编译时，去掉了调试信息。有方法解决吗？答案时肯定的。 解决方案 在你的D:盘新建jdk文件夹，然后在文件夹里面分别创建两个文件夹jdk_src（存放源码）和jdk_debug（存放编译结果文件）。 从%JAVA_HOME%路径下找到src.zip源码源码压缩包，解压至D:/jdk/jdk_src目录中，并只保留java，javax,org三个文件夹。 从%JAVA_HOME%\jre\lib找到rt.jar，将它拷贝到D:/jdk文件夹。 打开DOS命令窗口，用命令cd命令进入D:/jdk文件夹，然后执行命令 1dir /B /S /X .\jdk_src\*.java &gt; .\filelist.txt 完成后会在D:/jdk目录生成filelist.txt文件，里面为待编译的文件路径/.java。 执行命令 12javac -J-Xms16m -J-Xmx1024m -sourcepath .\jdk_src -cp .\rt.jar -d .\jdk_debug -g @.\filelist.txt &gt;&gt; .\log.txt 2&gt;&amp;1 会编译filelist.txt文件中列出的.java源文件，编译的.class文件会放入D:/jdk/jdk_debug文件夹，同时编译过程中会在D:/jdk生成log.txt文件。 执行cd命令切换到D:/jdk/jdk_debug，然后执行 1jar cf0 rt_debug.jar * 将.class文件打成jar，打包完成后会在D:/jdk/jdk_debug目录中生成rt_debug.jar。 把这个生成的rt_debug.jar包复制到%JAVA_HOME%\jre\lib\endorsed下。如果没有endorsed目录，自己创建一下。 在eclipse里面找到Window-&gt;Installed JRES，选择jdk，点击Edit，然后点击Add External jars，选择刚才创建的rt_debug.jar导入，然后把rt_debug.jar移动到rt.jar的前面，最后选中rt_debug.jar，点击Source Attachment选择%JAVA_HOME%/jdk/src.zip添加源文件，最后，重启eclipse。 注：本文参考一曲破东风]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>源码调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客快速入门]]></title>
    <url>%2F2018%2F05%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
